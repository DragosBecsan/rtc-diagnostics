import { EventEmitter } from 'events';
import {
  DiagnosticError,
  InvalidStateError,
  PromiseTimedOutError,
} from '../errors';
import {
  NetworkInformation,
  networkInformationPolyfill as networkInformation,
} from '../polyfills/NetworkInformation';
import { NetworkTiming, TimeMeasurement } from '../timing';
import { validateOptions, validateTime } from '../utils/OptionValidation';
import { waitForPromise } from '../utils/TimeoutPromise';
import { TestCall } from './TestCall';

export declare interface NetworkTest {
  /**
   * This event is emitted when the test ends. Emits a [[NetworkTest.Report]]
   * summarizing the run time of the test.
   * @param event [[NetworkTest.Events.End]]
   * @param report The report summarizing the run time of the test.
   * @private
   */
  emit(
    event: NetworkTest.Events.End,
    report: NetworkTest.Report,
  ): boolean;
  /**
   * This event is emitted when the test encounters an error, fatal or not.
   * Emits the [[DiagnosticError]] encountered.
   * @param event [[NetworkTest.Events.Error]]
   * @param error The [[DiagnosticError]] encountered, fatal or not.
   * @private
   */
  emit(
    event: NetworkTest.Events.Error,
    error: DiagnosticError,
  ): boolean;

  /**
   * Fires when the test ends. Will pass a [[NetworkTest.Report]] to the
   * handler.
   * @param event [[NetworkTest.Events.End]]
   * @param listener A callback expecting the following parameters:
   * - A [[NetworkTest.Report]] summarizing the run time of the test.
   * @returns This [[NetworkTest]] instance.
   */
  on(
    event: NetworkTest.Events.End,
    listener: (report: NetworkTest.Report,
  ) => any): this;
  /**
   * Fires when the test encounters an error, fatal or not. Will pass the
   * error to the handler.
   * @param event [[NetworkTest.Events.End]]
   * @param listener A callback expecting the following parameters:
   * - A [[DiagnosticError]] representing the error.
   * @returns This [[NetworkTest]] instance.
   */
  on(
    event: NetworkTest.Events.Error,
    listener: (error: DiagnosticError) => any,
  ): this;
}

/**
 * Network test class that parses input options and creates an [[TestCall]] with
 * those options. This test can be used to test connectivity to any set of
 * given ICE servers, and is optionally able to filter those servers by
 * TCP or UDP protocol, and by STUN or TURN.
 *
 * This class also summarizes the events of the [[TestCall]] it uses internally
 * and emits them.
 */
export class NetworkTest extends EventEmitter {
  /**
   * Default options for the [[NetworkTest]]. These will be overwritten by any
   * option passed in the [[NetworkTest.constructor]] `options` parameter.
   */
  static defaultOptions: NetworkTest.Options = {
    networkInformation,
    timeoutMs: 5000,
  };
  /**
   * The test message that is sent from one end of the [[TestCall]] to the
   * other to determine connectivity through WebRTC.
   */
  static testMessage: string = 'Ahoy, world!';
  /**
   * The name of the [[NetworkTest]], included in the report that the test emits
   * at the end of its run time.
   */
  static testName: 'network-connectivity' = 'network-connectivity';

  /**
   * When the test ends, generated by a call to `Date.now` as soon as
   * [[NetworkTest._stop]] is called internally.
   */
  private _endTime: number | null = null;
  /**
   * Any errors that the [[NetworkTest]] encounters during its run time.
   */
  private _errors: DiagnosticError[] = [];
  /**
   * Timestamp when [[TestCall._recipient]] receives a message.
   */
  private _firstPacketTime: number | undefined;
  /**
   * Options that have been passed to the [[NetworkTest]].
   */
  private _options: NetworkTest.Options;
  /**
   * The configuration to pass to [[TestCall]].
   */
  private _peerConnectionConfig: RTCConfiguration;
  /**
   * When the test starts, set on construction.
   */
  private _startTime: number;
  /**
   * The [[TestCall]] used internally.
   */
  private _testCall: TestCall | null = null;

  /**
   * Initializes the test and starts it.
   * @param options Options to pass to the constructor.
   */
  constructor(options: Partial<NetworkTest.Options> = {}) {
    super();

    this._options = { ...NetworkTest.defaultOptions, ...options };

    this._startTime = Date.now();
    this._peerConnectionConfig = {
      iceServers: this._options.iceServers,
    };

    setTimeout(() => this._startTest());
  }

  /**
   * Determine if the test has passed or not.
   */
  private _determinePass(): boolean {
    return this._errors.length === 0;
  }

  /**
   * Adds the error to the internal list of errors that have occured, which will
   * be included in the final test report.
   * @param error
   */
  private _onError(error: DiagnosticError): void {
    this._errors.push(error);
    this.emit(NetworkTest.Events.Error, error);
  }

  /**
   * Starts the test by connecting the two [[RTCPeerConnection]] ends of the
   * [[TestCall]] and then attempting to send a message from one end to the
   * other. If this process takes
   */
  private async _startTest(): Promise<void> {
    try {
      await validateOptions(this._options, { timeoutMs: validateTime });

      this._testCall = new TestCall({
        peerConnectionConfig: this._peerConnectionConfig,
        peerConnectionFactory: this._options.peerConnectionFactory,
        timeoutDuration: this._options.timeoutMs,
      });

      // Set up a promise that resolves when we receive the correct message
      // on the receiving PeerConnection
      const waitReceivedMessage: Promise<void> = new Promise(
        (resolve: () => void, reject: (error: InvalidStateError) => void): void => {
          if (!this._testCall) {
            reject(new InvalidStateError('TestCall is `null`.'));
            return;
          }
          this._testCall.on(TestCall.Event.Message, (message: MessageEvent) => {
            if (message.data === NetworkTest.testMessage) {
              this._firstPacketTime = Date.now();
              resolve();
            }
          });
        },
      );

      // We race between two promises:
      // an async function that will resolve once we connect and we send and
      // receive a message,
      // and
      // the timeout promise signifying the test has timed out.

      // If an error occurs during the runtime of the async function, i.e.
      // while we are establishing a connection, sending a message, or waiting
      // for the message to be recieved, this rejection is forwarded to the
      // [[_onError]] handler of the NetworkTest.
      try {
        await waitForPromise((async (): Promise<void> => {
          if (!this._testCall) {
            throw new InvalidStateError('TestCall is `null`.');
          }
          await this._testCall.establishConnection();
          this._testCall.send(NetworkTest.testMessage);
          await waitReceivedMessage;
        })(), this._options.timeoutMs);
      } catch (error) {
        if (error instanceof PromiseTimedOutError) {
          throw new DiagnosticError(
            undefined,
            'NetworkTest timeout, the PeerConnection did not receive the ' +
            'message.',
          );
        } else {
          // Re-throw the error so the handler at the end of `_startTest`
          // can handle it properly.
          throw error;
        }
      }

      // If none of the Promises reject, then we successfully received the
      // `testMessage`.
      this._stop(true);
    } catch (error) {
      if (error instanceof DiagnosticError) {
        this._onError(error);
      } else if (
        typeof DOMException !== 'undefined' && error instanceof DOMException
      ) {
        // Could be thrown by the PeerConnections during the call
        // `testCall.establishConnection`.
        this._onError(new DiagnosticError(
          error,
          'A `DOMException` occurred.',
        ));
      } else if (
        typeof DOMError !== 'undefined' && error instanceof DOMError
      ) {
        this._onError(new DiagnosticError(
          error,
          'A `DOMError` occurred.',
        ));
      } else {
        // An unknown error occurred.
        this._onError(error);
      }
      this._stop(false);
    }
  }

  /**
   * Stop the `NetworkTest`. This performs cleanup on the [[TestCall]] and
   * emits a report for the test.
   * @param didPass Override the check. Useful when encountering a fatal error.
   */
  private _stop(didPass: boolean = true): void {
    if (this._testCall) {
      this._testCall.close();
    }

    // Use the network information polyfill, if the info is `undefined` then
    // use an empty object so all members will be `undefined`.
    const info: NetworkInformation = this._options.networkInformation || {};

    this._endTime = Date.now();

    const networkTiming: NetworkTiming = this._testCall
      ? this._testCall.networkTiming
      : {};
    if (this._firstPacketTime) {
      networkTiming.firstPacket = this._firstPacketTime;
    }

    // We are unable to use the spread operator here on `networkInformation`,
    // the values will always be `undefined`.
    const report: NetworkTest.Report = {
      didPass: didPass && this._determinePass(),
      downlink: info.downlink,
      downlinkMax: info.downlinkMax,
      effectiveType: info.effectiveType,
      errors: this._errors,
      networkTiming,
      rtt: info.rtt,
      saveData: info.saveData,
      testName: NetworkTest.testName,
      testTiming: {
        duration: this._endTime - this._startTime,
        end: this._endTime,
        start: this._startTime,
      },
      type: info.type,
    };

    this.emit(NetworkTest.Events.End, report);
  }
}

export namespace NetworkTest {
  /**
   * Possible options for the [[NetworkTest]].
   */
  export interface Options {
    /**
     * A list of `RTCIceServer` credentials for the two `RTCPeerConnection`s to
     * use.
     */
    iceServers?: RTCIceServer[];
    /**
     * A `NetworkInformation` connection. Used for mocking.
     * @private
     */
    networkInformation?: NetworkInformation;
    /**
     * A `PeerConnection` factory to be used, mainly for Mocking.
     * @private
     */
    peerConnectionFactory?: typeof RTCPeerConnection;
    /**
     * Timeout in milliseconds. This causes a [[DiagnosticError]] if the test is
     * unable to connect and send and receive a message within this timeout.
     */
    timeoutMs: number;
  }
  /**
   * Events that the [[NetworkTest]] will emit.
   */
  export enum Events {
    End = 'end',
    Error = 'error',
  }
  /**
   * A test report that is emitted with the [[NetworkTest.End]] event.
   */
  export interface Report {
    /**
     * Whether or not the [[NetworkTest]] has passed.
     */
    didPass: boolean;
    /**
     * NetworkInformation downlink
     */
    downlink?: number;
    /**
     * NetworkInformation downlinkMax
     */
    downlinkMax?: number;
    /**
     * NetworkInformation effectiveType
     */
    effectiveType?: string;
    /**
     * Any error that occured during the run-time of the test.
     */
    errors: DiagnosticError[];
    /**
     * Timestamps of various network events as the [[TestCall]] runs.
     */
    networkTiming: NetworkTiming;
    /**
     * NetworkInformation rtt
     */
    rtt?: number;
    /**
     * NetworkInformation saveData
     */
    saveData?: boolean;
    /**
     * The name of the [[NetworkTest]].
     */
    testName: typeof NetworkTest.testName;
    /**
     * When the [[NetworkTest]] starts and ends, and the duration.
     * Set on construction and when the end event fires.
     */
    testTiming: TimeMeasurement;
    /**
     * NetworkInformation type
     */
    type?: string;
  }
}

/**
 * Helper function that instanciates a [[NetworkTest]] and returns a promise
 * that resolves when the [[NetworkTest]] ends, and rejects if it errors.
 * @param options the options to pass to the [[NetworkTest]].
 */
export function testNetwork(
  options?: Partial<NetworkTest.Options>,
): NetworkTest {
  return new NetworkTest(options);
}
