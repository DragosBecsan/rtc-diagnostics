{"version":3,"file":"audio.js","sourceRoot":"","sources":["../../../lib/recorder/audio.ts"],"names":[],"mappings":";;AAAA,oCAA4C;AAE5C,qCAAoC;AAEpC;;;;;GAKG;AACH;IA0BE;;;;OAIG;IACH,uBAAY,OAAsC;QAAlD,iBAMC;;QApCD;;WAEG;QACK,eAAU,GAAoC,EAAE,CAAC;QAOzD;;WAEG;QACK,iBAAY,GAAoC,IAAI,CAAC;QAO7D;;WAEG;QACK,SAAI,GAAW,EAAE,CAAC;QAQxB,IAAM,OAAO,eAAG,OAAO,CAAC,oBAAoB,uCAAK,MAAc,CAAC,aAAa,yCAAI,iBAAO,EAAA,CAAC;QACzF,IAAI,CAAC,OAAO,GAAG,OAAO,CAAC,MAAM,CAAC,KAAK,EAAE,CAAC;QACtC,IAAI,CAAC,cAAc,GAAG,IAAI,OAAO,CAAC,IAAI,CAAC,OAAO,EAAE,OAAO,CAAC,YAAY,CAAC,CAAC;QACtE,IAAI,CAAC,cAAc,CAAC,eAAe,GAAG,UAAC,CAAgC,IAAK,OAAA,KAAI,CAAC,UAAU,CAAC,IAAI,CAAC,CAAC,CAAC,IAAI,CAAC,EAA5B,CAA4B,CAAC;QACzG,IAAI,CAAC,cAAc,CAAC,KAAK,EAAE,CAAC;IAC9B,CAAC;IAED;;;OAGG;IACH,4BAAI,GAAJ;QAAA,iBAkBC;QAjBC,IAAI,IAAI,CAAC,YAAY,EAAE;YACrB,OAAO,OAAO,CAAC,MAAM,CAAC,IAAI,wBAAe,CAAC,SAAS,EAAE,mCAAmC,CAAC,CAAC,CAAC;SAC5F;QACD,IAAI,CAAC,YAAY,GAAG,IAAI,OAAO,CAAC,UAAC,OAAO,EAAE,MAAM;YAC9C,KAAI,CAAC,cAAc,CAAC,MAAM,GAAG;gBAC3B,IAAI;oBACF,KAAI,CAAC,OAAO,CAAC,SAAS,EAAE,CAAC,OAAO,CAAC,UAAC,KAAuB,IAAK,OAAA,KAAK,CAAC,IAAI,EAAE,EAAZ,CAAY,CAAC,CAAC;oBAC5E,KAAI,CAAC,kBAAkB,EAAE,CAAC;iBAC3B;gBAAC,OAAO,EAAE,EAAE;oBACX,MAAM,CAAC,IAAI,wBAAe,CAAC,EAAE,EAAE,+BAA+B,CAAC,CAAC,CAAC;oBACjE,OAAO;iBACR;gBACD,OAAO,EAAE,CAAC;YACZ,CAAC,CAAC;YACF,KAAI,CAAC,cAAc,CAAC,IAAI,EAAE,CAAC;QAC7B,CAAC,CAAC,CAAC;QACH,OAAO,IAAI,CAAC,YAAY,CAAC;IAC3B,CAAC;IAED;;OAEG;IACK,0CAAkB,GAA1B;QACE,iDAAiD;QACjD,qDAAqD;QACrD,IAAM,IAAI,GAAW,IAAI,CAAC,cAAc,IAAI,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,IAAI,CAAC,cAAc,CAAC,QAAQ,CAAC,CAAC,CAAC,WAAW,CAAC;QACtH,IAAM,IAAI,GAAG,IAAI,IAAI,CAAC,IAAI,CAAC,UAAU,EAAE,EAAE,IAAI,MAAA,EAAE,CAAC,CAAC;QACjD,IAAI,CAAC,IAAI,GAAG,GAAG,CAAC,eAAe,CAAC,IAAI,CAAC,CAAC;QACtC,IAAI,CAAC,UAAU,GAAG,EAAE,CAAC;IACvB,CAAC;IAKD,sBAAI,8BAAG;QAHP;;WAEG;aACH;YACE,OAAO,IAAI,CAAC,IAAI,CAAC;QACnB,CAAC;;;OAAA;IACH,oBAAC;AAAD,CAAC,AAjFD,IAiFC;AAjFY,sCAAa","sourcesContent":["import { DiagnosticError } from '../errors';\nimport { MediaStreamRecorder } from '../types';\nimport { Encoder } from './encoder';\n\n/**\n * The [[AudioRecorder]] allows cross browser recording of audio from an input MediaStream.\n * It uses the native MediaStream Recording APIs if available, else, it process raw audio data\n * and converts it to a blob.\n * @internalapi\n */\nexport class AudioRecorder {\n  /**\n   * The raw audio data captured during the test\n   */\n  private _audioData: MediaStreamRecorder.AudioData[] = [];\n\n  /**\n   * The MediaRecorder instance to be used for capturing audio\n   */\n  private _mediaRecorder: MediaStreamRecorder.MediaRecorder;\n\n  /**\n   * Promise handle after calling .stop()\n   */\n  private _stopPromise: Promise<DiagnosticError> | null = null;\n\n  /**\n   * The source input stream\n   */\n  private _stream: MediaStream;\n\n  /**\n   * The resuling object url that can be used for audio playback\n   */\n  private _url: string = '';\n\n  /**\n   * Construct an [[AudioRecorder]] instance and will start the recording immediately.\n   * @constructor\n   * @param options\n   */\n  constructor(options: AudioRecorder.ExtendedOptions) {\n    const factory = options.MediaRecorderFactory ?? (window as any).MediaRecorder ?? Encoder;\n    this._stream = options.stream.clone();\n    this._mediaRecorder = new factory(this._stream, options.audioContext);\n    this._mediaRecorder.ondataavailable = (e: MediaStreamRecorder.DataEvent) => this._audioData.push(e.data);\n    this._mediaRecorder.start();\n  }\n\n  /**\n   * Stops the recording process.\n   * If successful, the `.url` property will be populated.\n   */\n  stop(): Promise<DiagnosticError | null> {\n    if (this._stopPromise) {\n      return Promise.reject(new DiagnosticError(undefined, 'MediaRecorder has already stopped'));\n    }\n    this._stopPromise = new Promise((resolve, reject) => {\n      this._mediaRecorder.onstop = () => {\n        try {\n          this._stream.getTracks().forEach((track: MediaStreamTrack) => track.stop());\n          this._generateObjectUrl();\n        } catch (ex) {\n          reject(new DiagnosticError(ex, 'Unable to generate Object URL'));\n          return;\n        }\n        resolve();\n      };\n      this._mediaRecorder.stop();\n    });\n    return this._stopPromise;\n  }\n\n  /**\n   * Generates the object url that can be used for audio playback from raw audio data\n   */\n  private _generateObjectUrl(): void {\n    // Select default browser mime type if it exists.\n    // Otherwise, use wav for faster and simple encoding.\n    const type: string = this._mediaRecorder && this._mediaRecorder.mimeType ? this._mediaRecorder.mimeType : 'audio/wav';\n    const blob = new Blob(this._audioData, { type });\n    this._url = URL.createObjectURL(blob);\n    this._audioData = [];\n  }\n\n  /**\n   * The resuling object url that can be used for audio playback\n   */\n  get url(): string {\n    return this._url;\n  }\n}\n\n/**\n * @internalapi\n */\nexport namespace AudioRecorder {\n  /**\n   * Options that may be passed to [[AudioRecorder]] constructor for internal testing.\n   * @internalapi\n   */\n  export interface ExtendedOptions extends Options {\n    /**\n     * The MediaRecorder class to use for testing\n     */\n    MediaRecorderFactory?: any;\n  }\n\n  /**\n   * Options passed to [[AudioRecorder]] constructor.\n   * @internalapi\n   */\n  export interface Options {\n    /**\n     * The AudioContext instance to use\n     */\n    audioContext: AudioContext;\n\n    /**\n     * The source input stream\n     */\n    stream: MediaStream;\n  }\n}\n"]}