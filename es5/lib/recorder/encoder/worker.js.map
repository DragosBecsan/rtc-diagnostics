{"version":3,"file":"worker.js","sourceRoot":"","sources":["../../../../lib/recorder/encoder/worker.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Encodes raw buffer into a wav format\n * Copied from https://github.com/chris-rudmin/Recorderjs\n * @internalapi\n */\n/* tslint:disable */\nconst waveEncoder = () => {\n  let BYTES_PER_SAMPLE = 2\n\n  let recorded: any = []\n\n  function encode (buffer: any) {\n    let length = buffer.length\n    let data = new Uint8Array(length * BYTES_PER_SAMPLE)\n    for (let i = 0; i < length; i++) {\n      let index = i * BYTES_PER_SAMPLE\n      let sample = buffer[i]\n      if (sample > 1) {\n        sample = 1\n      } else if (sample < -1) {\n        sample = -1\n      }\n      sample = sample * 32768\n      data[index] = sample\n      data[index + 1] = sample >> 8\n    }\n    recorded.push(data)\n  }\n\n  function dump (sampleRate: any) {\n    let bufferLength = recorded.length ? recorded[0].length : 0\n    let length = recorded.length * bufferLength\n    let wav = new Uint8Array(44 + length)\n    let view = new DataView(wav.buffer)\n\n    // RIFF identifier 'RIFF'\n    view.setUint32(0, 1380533830, false)\n    // file length minus RIFF identifier length and file description length\n    view.setUint32(4, 36 + length, true)\n    // RIFF type 'WAVE'\n    view.setUint32(8, 1463899717, false)\n    // format chunk identifier 'fmt '\n    view.setUint32(12, 1718449184, false)\n    // format chunk length\n    view.setUint32(16, 16, true)\n    // sample format (raw)\n    view.setUint16(20, 1, true)\n    // channel count\n    view.setUint16(22, 1, true)\n    // sample rate\n    view.setUint32(24, sampleRate, true)\n    // byte rate (sample rate * block align)\n    view.setUint32(28, sampleRate * BYTES_PER_SAMPLE, true)\n    // block align (channel count * bytes per sample)\n    view.setUint16(32, BYTES_PER_SAMPLE, true)\n    // bits per sample\n    view.setUint16(34, 8 * BYTES_PER_SAMPLE, true)\n    // data chunk identifier 'data'\n    view.setUint32(36, 1684108385, false)\n    // data chunk length\n    view.setUint32(40, length, true)\n\n    for (let i = 0; i < recorded.length; i++) {\n      wav.set(recorded[i], i * bufferLength + 44)\n    }\n\n    recorded = []\n    postMessage(wav.buffer, [wav.buffer] as any)\n  }\n\n  onmessage = e => {\n    if (e.data[0] === 'encode') {\n      encode(e.data[1])\n    } else if (e.data[0] === 'dump') {\n      dump(e.data[1])\n    }\n  }\n}\n\nexport { waveEncoder };\n"]}