{"version":3,"file":"InputTest.js","sourceRoot":"","sources":["../../lib/InputTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { TestName, WarningName } from './constants';\nimport {\n  AlreadyStoppedError,\n  DiagnosticError,\n  InvalidOptionsError,\n} from './errors';\nimport {\n  AudioContext,\n  AudioContextUnsupportedError,\n  enumerateDevices,\n  EnumerateDevicesUnsupportedError,\n  getDefaultDevices,\n  getUserMedia,\n  GetUserMediaUnsupportedError,\n} from './polyfills';\nimport { AudioRecorder } from './recorder/audio';\nimport { SubsetRequired, TimeMeasurement, VolumeStats } from './types';\nimport { detectSilence } from './utils';\nimport {\n  InvalidityRecord,\n  validateDeviceId,\n  validateOptions,\n  validateTime,\n} from './utils/optionValidation';\n\nexport declare interface InputTest {\n  /**\n   * This event is emitted with a boolean representing if the test passed and a\n   * test report when the test ends.\n   * @param event [[InputTest.Events.End]]\n   * @param report Summary of the test.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.End,\n    report: InputTest.Report,\n  ): boolean;\n  /**\n   * This event is emitted with a [[DiagnosticError]] when the test encounters\n   * an error, fatal or not.\n   * @param event [[InputTest.Events.Error]]\n   * @param error The [[DiagnosticError]] that was encountered.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.Error,\n    error: DiagnosticError,\n  ): boolean;\n  /**\n   * This event is emitted with a volume level every\n   * [[InputTest.Options.volumeEventIntervalMs]] after the test starts succesfully.\n   * @param event [[InputTest.Events.Volume]]\n   * @param value The current volume of the audio source.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.Volume,\n    value: number,\n  ): boolean;\n  /**\n   * This event is emitted when the test encounters a non-fatal warning during\n   * its run-time.\n   * @param event [[InputTest.Events.Warning]]\n   * @param warning The warning that the test encountered.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.Warning,\n    warning: WarningName,\n  ): boolean;\n  /**\n   * This event is emitted when the test clears a previously encountered\n   * non-fatal warning during its run-time.\n   * @param event [[InputTest.Events.WarningCleared]]\n   * @param warning The warning that the test encountered that should be cleared.\n   * @private\n   */\n  emit(\n    event: InputTest.Events.WarningCleared,\n    warning: WarningName,\n  ): boolean;\n\n  /**\n   * Raised upon completion of the test.\n   * @param event [[InputTest.Events.End]]\n   * @param listener A callback that expects the following parameters:\n   *  An [[InputTest.Report]] that summarizes the test.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.End,\n    listener: (report: InputTest.Report) => any,\n  ): this;\n  /**\n   * Raised by the test when encountering an error with a parameter of type\n   * [[DiagnosticError]].\n   * @param event [[InputTest.Events.Error]]\n   * @param listener A callback that expects the following parameters:\n   *  A [[DiagnosticError]] that the test encountered.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n  /**\n   * Raised by the test every [[Options.volumeEventIntervalMs]] amount of\n   * milliseconds with a parameter of type `number` that represents the\n   * current volume of the audio stream.\n   * @param event [[InputTest.Events.Volume]]\n   * @param listener A callback that expects the following parameters:\n   *  A `number` that represents the audio source's current volume.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.Volume,\n    listener: (value: number) => any,\n  ): this;\n  /**\n   * Raised by the test when the test encounters a non-fatal warning during\n   * its run-time.\n   * @param event [[InputTest.Events.Warning]]\n   * @param listener A callback that expects the following parameters:\n   *  A [[DiagnosticWarning]].\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.Warning,\n    listener: (warning: WarningName) => any,\n  ): this;\n  /**\n   * Raised by the test when the test clears a previously encountered non-fatal\n   * warning during its run-time.\n   * @param event [[InputTest.Events.WarningCleared]]\n   * @param listener A callback that expects the following parameters:\n   *  A [[DiagnosticWarning]] name.\n   * @returns This [[InputTest]] instance.\n   * @event\n   */\n  on(\n    event: InputTest.Events.WarningCleared,\n    listener: (warning: WarningName) => any,\n  ): this;\n}\n\n/**\n * [[InputTest]] class that parses options and starts an audio input device\n * test.\n *\n * Please see [[testInputDevice]] for details and recommended practices.\n */\nexport class InputTest extends EventEmitter {\n  /**\n   * Name of the test.\n   */\n  static testName: TestName.InputAudioDevice = TestName.InputAudioDevice;\n\n  /**\n   * Default options for the `InputTest`.\n   */\n  private static defaultOptions: InputTest.InternalOptions = {\n    audioContextFactory: AudioContext,\n    audioRecorderFactory: AudioRecorder,\n    debug: false,\n    duration: Infinity,\n    enableRecording: false,\n    enumerateDevices,\n    getUserMedia,\n    volumeEventIntervalMs: 100,\n  };\n\n  /**\n   * Active warnings to keep track of.\n   */\n  readonly activeWarnings: Set<WarningName> = new Set();\n\n  /**\n   * An `AudioContext` to use for generating volume levels.\n   */\n  private _audioContext: AudioContext | null = null;\n  /**\n   * An AudioRecorder object used to capture audio input during the test\n   */\n  private _audioRecorder: AudioRecorder | null = null;\n  /**\n   * A function that will be assigned in `_startTest` that when run will clean\n   * up the audio nodes created in the same function.\n   */\n  private _cleanupAudio: (() => void) | null = null;\n  /**\n   * The default media devices when starting the test.\n   */\n  private _defaultDevices: Partial<Record<\n    MediaDeviceKind,\n    MediaDeviceInfo\n  >> = {};\n  /**\n   * A timestamp that is set when the test ends.\n   */\n  private _endTime: number | null = null;\n  /**\n   * An array of any errors that occur during the run time of the test.\n   */\n  private readonly _errors: DiagnosticError[] = [];\n  /**\n   * A `MediaStream` that is created from the input device.\n   */\n  private _mediaStream: MediaStream | null = null;\n  /**\n   * Options that are passed to and set in the constructor for use during the\n   * test.\n   */\n  private _options: InputTest.InternalOptions;\n  /**\n   * A timestamp that is set when the test starts after a successful call to getUserMedia.\n   */\n  private _startTime: number | undefined;\n  /**\n   * Volume levels generated from the audio source during the run time of the\n   * test.\n   */\n  private readonly _volumeStats: VolumeStats = {\n    timestamps: [],\n    values: [],\n  };\n  /**\n   * The timeout that causes the volume event to loop; created by `setTimeout`.\n   */\n  private _volumeTimeout: NodeJS.Timeout | null = null;\n\n  /**\n   * Initializes the `startTime` and `options`.\n   * @param options Optional settings to pass to the test.\n   */\n  constructor(options?: InputTest.Options) {\n    super();\n\n    this._options = { ...InputTest.defaultOptions, ...options };\n\n    // We need to use a `setTimeout` here to prevent a race condition.\n    // This allows event listeners to bind before the test starts.\n    setTimeout(() => this._startTest());\n  }\n\n  /**\n   * Stop the currently running `InputTest`.\n   * @param pass whether or not the test should pass. If set to false, will\n   * override the result from determining whether audio is silent from the collected volume levels.\n   */\n  stop(pass: boolean = true): void {\n    if (typeof this._endTime === 'number') {\n      this._onWarning(new AlreadyStoppedError());\n      return;\n    }\n\n    this._endTime = Date.now();\n    const didPass: boolean = pass && !detectSilence(this._volumeStats.values);\n    const report: InputTest.Report = {\n      deviceId: this._options.deviceId || (\n        this._defaultDevices.audioinput &&\n        this._defaultDevices.audioinput.deviceId\n      ),\n      didPass,\n      errors: this._errors,\n      testName: InputTest.testName,\n      values: this._volumeStats.values,\n    };\n\n    if (this._startTime) {\n      report.testTiming = {\n        duration: this._endTime - this._startTime,\n        end: this._endTime,\n        start: this._startTime,\n      };\n    }\n\n    const onEnd = () => {\n      this._cleanup();\n      this.emit(InputTest.Events.End, report);\n    };\n\n    if (this._options.enableRecording && this._audioRecorder) {\n      this._audioRecorder.stop().then(() => {\n        report.recordingUrl = this._audioRecorder!.url;\n      }).catch((ex: DiagnosticError) => {\n        this._onError(ex);\n        report.didPass = false;\n      }).finally(onEnd);\n    } else {\n      onEnd();\n    }\n  }\n\n  /**\n   * Clean up any instantiated objects (i.e. `AudioContext`, `MediaStreams`,\n   * etc.).\n   * Called by `.stop`.\n   */\n  private _cleanup(): void {\n    if (this._volumeTimeout) {\n      clearTimeout(this._volumeTimeout);\n    }\n    if (this._cleanupAudio) {\n      this._cleanupAudio();\n    }\n    if (this._mediaStream) {\n      this._mediaStream.getTracks().forEach(\n        (track: MediaStreamTrack) => track.stop(),\n      );\n    }\n    if (this._audioContext) {\n      this._audioContext.close();\n    }\n  }\n\n  /**\n   * Helper function that should be called when an error occurs, recoverable\n   * or not.\n   * @param error\n   */\n  private _onError(error: DiagnosticError): void {\n    this._errors.push(error);\n    this.emit(InputTest.Events.Error, error);\n  }\n\n  /**\n   * Called every `InputTest._options.volumeEventIntervalMs` amount of\n   * milliseconds, emits the volume passed to it as a `Events.Volume` event.\n   * @param value the volume\n   */\n  private _onVolume(value: number): void {\n    const now = Date.now();\n\n    if (!this._volumeStats.max || value > this._volumeStats.max) {\n      this._volumeStats.max = value;\n    }\n    this._volumeStats.values.push(value);\n    this._volumeStats.timestamps.push(now);\n    this.emit(InputTest.Events.Volume, value);\n\n    // Find the last 3 seconds worth of volume values.\n    const startIndex = this._volumeStats.timestamps.findIndex(\n      (timestamp: number) => now - timestamp <= 3000,\n    );\n\n    // We want to do nothing at 1 and not 0 here because this guarantees that\n    // there is at least one timestamp before the sample set. This means that\n    // there are at least three seconds of samples.\n    if (startIndex < 1) {\n      return;\n    }\n\n    const samples = this._volumeStats.values.slice(\n      startIndex > 0\n        ? startIndex\n        : 0,\n    );\n\n    // Calculate the standard deviation of the sample set.\n    const sampleAverage = samples.reduce(\n      (sample: number, partialSum: number) => sample + partialSum,\n      0,\n    ) / samples.length;\n    const diffSquared = samples.map(\n      (sample: number) => Math.pow(sample - sampleAverage, 2),\n    );\n    const stdDev = Math.sqrt(diffSquared.reduce(\n      (sample: number, partialSum: number) => sample + partialSum,\n      0,\n    ) / samples.length);\n\n    // 255 is max volume value; 2.55 is 1% of max\n    const isConstantAudio = stdDev <= 2.55;\n    if (isConstantAudio && sampleAverage <= 2.55) {\n      if (!this.activeWarnings.has(WarningName.LowAudioLevel)) {\n        this.activeWarnings.add(WarningName.LowAudioLevel);\n        this.emit(InputTest.Events.Warning, WarningName.LowAudioLevel);\n      }\n    } else if (this.activeWarnings.has(WarningName.LowAudioLevel)) {\n      this.activeWarnings.delete(WarningName.LowAudioLevel);\n      this.emit(InputTest.Events.WarningCleared, WarningName.LowAudioLevel);\n    }\n  }\n\n  /**\n   * Warning event handler.\n   * @param warning\n   */\n  private _onWarning(error: DiagnosticError): void {\n    if (this._options.debug) {\n      // tslint:disable-next-line no-console\n      console.warn(error);\n    }\n  }\n\n  /**\n   * Entry point into the input device test. Uses the `MediaStream` that the\n   * object was set up with, and performs a fourier transform on the audio data\n   * using an `AnalyserNode`. The output of the fourier transform are the\n   * relative amplitudes of the frequencies of the audio data. The average of\n   * this data can then be used as an estimate as the average volume of the\n   * entire volume source.\n   *\n   * @event Events.Volume\n   */\n  private async _startTest(): Promise<void> {\n    try {\n      // Try to validate all of the inputs before starting the test.\n      // We perform this check here so if the validation throws, it gets handled\n      // properly as a fatal-error and we still emit a report with that error.\n      const invalidReasons: InvalidityRecord<InputTest.Options> | undefined =\n        await validateOptions<InputTest.Options>(this._options, {\n          deviceId: validateDeviceId,\n          duration: validateTime,\n          volumeEventIntervalMs: validateTime,\n        });\n      if (invalidReasons) {\n        throw new InvalidOptionsError(invalidReasons);\n      }\n\n      if (!this._options.getUserMedia) {\n        throw GetUserMediaUnsupportedError;\n      }\n      this._mediaStream = await this._options.getUserMedia({\n        audio: { deviceId: this._options.deviceId },\n      });\n\n      if (!this._options.audioContextFactory) {\n        throw AudioContextUnsupportedError;\n      }\n\n      // We need to initialize AudioContext and MediaRecorder right after calling gUM\n      // and before enumerateDevices. Certain browsers and headsets (Safari, AirPods)\n      // loses the \"user action\" after enumerating devices.\n      this._audioContext = new this._options.audioContextFactory();\n      if (this._options.enableRecording) {\n        this._audioRecorder = new this._options.audioRecorderFactory!({\n          audioContext: this._audioContext,\n          stream: this._mediaStream,\n        });\n      }\n\n      if (!this._options.enumerateDevices) {\n        throw EnumerateDevicesUnsupportedError;\n      }\n      this._defaultDevices = getDefaultDevices(\n        await this._options.enumerateDevices(),\n      );\n\n      // Only starts the timer after successfully getting devices\n      this._startTime = Date.now();\n\n      const analyser: AnalyserNode = this._audioContext.createAnalyser();\n      analyser.smoothingTimeConstant = 0.4;\n      analyser.fftSize = 64;\n\n      const microphone: MediaStreamAudioSourceNode =\n        this._audioContext.createMediaStreamSource(this._mediaStream);\n      microphone.connect(analyser);\n\n      this._cleanupAudio = (): void => {\n        analyser.disconnect();\n        microphone.disconnect();\n      };\n\n      const frequencyDataBytes: Uint8Array =\n        new Uint8Array(analyser.frequencyBinCount);\n\n      // This function runs every `this._options.reportRate` ms and emits the\n      // current volume of the `MediaStream`.\n      const volumeEvent: () => void = (): void => {\n        if (this._endTime) {\n          return;\n        }\n\n        analyser.getByteFrequencyData(frequencyDataBytes);\n        const volume: number =\n          frequencyDataBytes.reduce(\n            (sum: number, val: number) => sum + val,\n            0,\n          ) / frequencyDataBytes.length;\n        this._onVolume(volume);\n\n        if (Date.now() - this._startTime! > this._options.duration) {\n          this.stop();\n        } else {\n          this._volumeTimeout = setTimeout(\n            volumeEvent,\n            this._options.volumeEventIntervalMs,\n          );\n        }\n      };\n\n      this._volumeTimeout = setTimeout(\n        volumeEvent,\n        this._options.volumeEventIntervalMs,\n      );\n    } catch (error) {\n      if (error instanceof DiagnosticError) {\n        // There is some other fatal error.\n        this._onError(error);\n      } else if (\n        typeof DOMException !== 'undefined' && error instanceof DOMException\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMException` has occurred.',\n        ));\n      } else if (\n        typeof DOMError !== 'undefined' && error instanceof DOMError\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMError` has occurred.',\n        ));\n      } else {\n        this._onError(new DiagnosticError(\n          undefined,\n          'Unknown error occurred.',\n        ));\n        this._onWarning(error);\n      }\n      this.stop(false);\n    }\n  }\n}\n\nexport namespace InputTest {\n  /**\n   * Possible events that an `InputTest` might emit. See [[InputTest.on]].\n   */\n  export enum Events {\n    End = 'end',\n    Error = 'error',\n    Volume = 'volume',\n    Warning = 'warning',\n    WarningCleared = 'warning-cleared',\n  }\n\n  /**\n   * Represents the report generated from an [[InputTest]].\n   */\n  export interface Report {\n    /**\n     * The device ID used to get a MediaStream from using [getUserMedia](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia).\n     */\n    deviceId: MediaTrackConstraintSet['deviceId'];\n\n    /**\n     * Whether or not the test passed. This is `true` if no errors were detected or if the volumes are not silent.\n     */\n    didPass: boolean;\n\n    /**\n     * Any errors that occurred during the test.\n     */\n    errors: DiagnosticError[];\n\n    /**\n     * If [[InputTest.Options.enableRecording]] is set to true,\n     * `recordingUrl` will be available in the report which can be used to playback captured audio from the microphone.\n     * Your application should revoke this URL if it is no longer needed.\n     *\n     * Example:\n     *\n     * ```ts\n     * const inputTest: InputTest = testInputDevice({ enableRecording: true });\n     * inputTest.on(InputTest.Events.End, (report: InputTest.Report) => {\n     *   const audioEl = new Audio();\n     *   audioEl.src = report.recordingUrl;\n     *   audioEl.play();\n     *\n     *   // Revoke the url if no longer needed\n     *   URL.revokeObjectURL(report.recordingUrl);\n     * });\n     * ```\n     */\n    recordingUrl?: string;\n\n    /**\n     * The name of the test.\n     */\n    testName: typeof InputTest.testName;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming?: TimeMeasurement;\n\n    /**\n     * The volume levels emitted by the test during its run-time.\n     */\n    values: number[];\n  }\n\n  /**\n   * Options passed to [[InputTest]] constructor.\n   */\n  export interface Options {\n    /**\n     * AudioContext mock to be used during the test.\n     * @private\n     */\n    audioContextFactory?: typeof window.AudioContext;\n\n    /**\n     * AudioRecorder mock to be used during the test.\n     * @private\n     */\n    audioRecorderFactory?: typeof AudioRecorder;\n\n    /**\n     * Whether or not to log debug statements to the console.\n     * @private\n     */\n    debug?: boolean;\n\n    /**\n     * The device ID to try to get a MediaStream from using [getUserMedia](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia).\n     */\n    deviceId?: MediaTrackConstraintSet['deviceId'];\n\n    /**\n     * Duration of time to run the test in ms.\n     * @default Infinity\n     */\n    duration?: number;\n\n    /**\n     * Whether the test should record the audio input or not.\n     * If set to true, [[InputTest.Report.recordingUrl]] will be available for audio playback.\n     * Your application should revoke this URL if it is no longer needed.\n     *\n     * Example:\n     *\n     * ```ts\n     * const inputTest: InputTest = testInputDevice({ enableRecording: true });\n     * inputTest.on(InputTest.Events.End, (report: InputTest.Report) => {\n     *   const audioEl = new Audio();\n     *   audioEl.src = report.recordingUrl;\n     *   audioEl.play();\n     *\n     *   // Revoke the url if no longer needed\n     *   URL.revokeObjectURL(report.recordingUrl);\n     * });\n     * ```\n     * @default false\n     */\n    enableRecording?: boolean;\n\n    /**\n     * Used to mock the call to `enumerateDevices`.\n     * @private\n     */\n    enumerateDevices?: typeof navigator.mediaDevices.enumerateDevices;\n\n    /**\n     * Used to mock calls to `getUserMedia`.\n     * @private\n     */\n    getUserMedia?: typeof window.navigator.mediaDevices.getUserMedia;\n\n    /**\n     * The interval between emissions of volume events in milliseconds.\n     * @default 100\n     */\n    volumeEventIntervalMs?: number;\n  }\n\n  /**\n   * Option typing after initialization, so we can have type guarantees.\n   * @private\n   */\n  export type InternalOptions = SubsetRequired<Options, 'duration' | 'volumeEventIntervalMs'>;\n}\n\n/**\n * [[InputTest]] tests audio input capabilities. It serves to help diagnose\n * potential audio device issues that would prevent audio from being recognized\n * in a WebRTC call.\n *\n * ---\n *\n * The [[InputTest]] class is an `EventEmitter` (please see [[InputTest.on]] for\n * events and their details) and helps to diagnose issues by capturing user\n * audio and emitting the volume levels detected in that media.\n * ```ts\n * import { InputTest, testInputDevice } from '@twilio/rtc-diagnostics';\n * const options: InputTest.Options = { ... };\n * // `options` may be left `undefined` to use default option values\n * const inputTest: InputTest = testInputDevice(options);\n * ```\n * Applications can use the volume events emitted by the test to update their UI\n * to show to the user whether or not their media was captured successfully.\n * ```ts\n * inputTest.on(InputTest.Events.Volume, (volume: number) => {\n *   ui.updateVolume(volume); // Update your UI with the volume value here.\n * });\n * ```\n * The test can be normally stopped two ways: allowing the test to time out and\n * stopping the test manually.\n *\n * If the test was allowed to time out, the value of\n * [[InputTest.Report.didPass]] will be determined by the ratio of silent volume\n * values in the captured media.\n *\n * To end the test manually, the application can ask the end-user to confirm\n * that the volume levels it emits are what the end-user expects. If so, the\n * application can call the [[InputTest.stop]] method with `true`. Otherwise,\n * if the audio values are not expected, the application can call\n * [[InputTest.stop]] with `false`.\n * ```ts\n * // The UI should indicate that if the volume values are what the user\n * // expects, they can click this button to pass and stop the test...\n * const volumeCorrectButton = ...;\n * volumeCorrectButton.addEventListener('click', () => {\n *   inputTest.stop(true);\n * });\n *\n * // ...otherwise, if the volume levels are not what they expect, they can\n * // click this.\n * const volumeIncorrectButton = ...;\n * volumeIncorrectButton.addEventListener('click', () => {\n *   inputTest.stop(false);\n * });\n * ```\n * Calling [[InputTest.stop]] will immediately end the test. The value of\n * [[InputTest.Report.didPass]] is determined from the ratio of silent audio\n * levels detected in the user media, but overwritten by passing `false` to\n * [[InputTest.stop]].\n *\n * ---\n *\n * The [[InputTest]] object will always emit a [[InputTest.Report]] with the\n * [[InputTest.Events.End]] event, regardless of the occurrence of errors during\n * the runtime of the test.\n *\n * Fatal errors will immediately end the test and emit a report such that the\n * value of [[InputTest.Report.didPass]] will be `false` and the value of\n * [[InputTest.Report.errors]] will contain the fatal error.\n *\n * Non-fatal errors will not end the test, but will be included in the value of\n * [[InputTest.Report.errors]] upon completion of the test.\n *\n * ---\n *\n * Note: In Firefox, `deviceId` will be ignored, and instead the user will get a\n * browser pop-up where they can select the device they want to use. This is\n * unavoidable as it is Firefox's implementation of `getUserMedia()`.\n *\n * In most browsers, such as Chrome and Safari, when `getUserMedia()` is called,\n * a prompt will ask the user for broad microphone-access permissions. Then, the\n * parameters passed to `getUserMedia()` will determine the device that is\n * captured.\n *\n * Firefox differs in that the prompt will ask for a specific input device.\n * Regardless of the parameters passed to `getUserMedia()`, the device\n * selected in that prompt will be captured. If the user opts to have the\n * browser \"Remember this selection\" within the prompt, the device that was\n * selected will be captured by every future `getUserMedia()` call as well.\n * This selection will persist even through changes in the system OS, i.e. when\n * default devices are changed. In order to change the device, the user has to\n * revoke the webpage's microphone-access permissions for the prompt to show\n * again.\n *\n * Please see this link for more information on microphone access in Firefox:\n * https://support.mozilla.org/en-US/kb/how-manage-your-camera-and-microphone-permissions\n *\n * ---\n *\n * The function [[testInputDevice]] serves as a factory function that accepts\n * [[InputTest.Options]] as its only parameter and will instantiate an\n * [[InputTest]] object with those options.\n * ```ts\n * import { InputTest, testInputDevice } from '@twilio/rtc-diagnostics';\n * const options: InputTest.Options = { ... };\n * const inputTest: InputTest = testInputDevice(options);\n * ```\n *\n * @param options Options to pass to the [[InputTest]] constructor.\n */\nexport function testInputDevice(\n  options?: InputTest.Options,\n): InputTest {\n  return new InputTest(options);\n}\n"]}