{"version":3,"file":"VideoInputTest.js","sourceRoot":"","sources":["../../lib/VideoInputTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  AlreadyStoppedError,\n  DiagnosticError,\n  InvalidOptionsError,\n} from './errors';\nimport {\n  getUserMedia,\n  GetUserMediaUnsupportedError,\n} from './polyfills';\nimport {\n  SubsetRequired,\n  TimeMeasurement,\n  VideoResolution,\n} from './types';\nimport {\n  InvalidityRecord,\n  validateDeviceId,\n  validateOptions,\n  validateTime,\n} from './utils/optionValidation';\n\nexport declare interface VideoInputTest {\n  /**\n   * This event is emitted with a test report when the test ends.\n   * @param event [[VideoInputTest.Events.End]]\n   * @param report Summary of the test.\n   * @private\n   */\n  emit(\n    event: VideoInputTest.Events.End,\n    report: VideoInputTest.Report,\n  ): boolean;\n  /**\n   * This event is emitted with a [[DiagnosticError]] when the test encounters\n   * an error, fatal or not.\n   * @param event [[VideoInputTest.Events.Error]]\n   * @param error The [[DiagnosticError]] that was encountered.\n   * @private\n   */\n  emit(\n    event: VideoInputTest.Events.Error,\n    error: DiagnosticError,\n  ): boolean;\n\n  /**\n   * Raised upon completion of the test.\n   * @param event [[VideoInputTest.Events.End]]\n   * @param listener A callback that expects the following parameters:\n   *  An [[VideoInputTest.Report]] that summarizes the test.\n   * @returns This [[VideoInputTest]] instance.\n   * @event\n   */\n  on(\n    event: VideoInputTest.Events.End,\n    listener: (report: VideoInputTest.Report) => any,\n  ): this;\n  /**\n   * Raised by the test when encountering an error with a parameter of type\n   * [[DiagnosticError]].\n   * @param event [[VideoInputTest.Events.Error]]\n   * @param listener A callback that expects the following parameters:\n   *  A [[DiagnosticError]] that the test encountered.\n   * @returns This [[VideoInputTest]] instance.\n   * @event\n   */\n  on(\n    event: VideoInputTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n}\n\n/**\n * [[VideoInputTest]] class that parses options and starts a video input device\n * test.\n *\n * Please see [[testVideoInputDevice]] for details and recommended practices.\n */\nexport class VideoInputTest extends EventEmitter {\n  /**\n   * The name of the test.\n   */\n  static readonly testName: string = 'video-input-test';\n  /**\n   * Default options for the test.\n   */\n  private static defaultOptions: VideoInputTest.InternalOptions = {\n    debug: false,\n    duration: Infinity,\n    getUserMedia,\n  };\n\n  /**\n   * Timestamp of when the test was ended.\n   */\n  private _endTime: number | null = null;\n  /**\n   * An array of any errors that occur during the run time of the test.\n   */\n  private readonly _errors: DiagnosticError[] = [];\n  /**\n   * Options to be used throughout the runtime of the test.\n   */\n  private _options: VideoInputTest.InternalOptions;\n  /**\n   * The promise returned by the `HTMLMediaElement` after playing the stream\n   * captured by `getUserMedia`.\n   */\n  private _playPromise: Promise<void> | null = null;\n  /**\n   * Timestamp of when the test was started.\n   */\n  private _startTime: number | undefined;\n  /**\n   * Timer ID of the test duration timeout.\n   */\n  private _timeoutId: NodeJS.Timeout | null = null;\n  /**\n   * The `MediaStream` resulting from calling `getUserMedia`.\n   */\n  private _userMediaStream: MediaStream | null = null;\n\n  /**\n   * Constructor for a [[VideoInputTest]] object.\n   * @param options Options to be used during the runtime of the test.\n   */\n  constructor(options?: VideoInputTest.Options) {\n    super();\n\n    this._options = { ...VideoInputTest.defaultOptions, ...options };\n\n    /**\n     * Use `setTimeout` to allow event listeners to properly bind before\n     * starting the test.\n     */\n    setTimeout(() => this._startTest());\n  }\n\n  /**\n   * Stops the test. Emits a report upon the end of the test.\n   */\n  stop(): void {\n    if (typeof this._endTime === 'number') {\n      this._onWarning(new AlreadyStoppedError());\n      return;\n    }\n\n    this._endTime = Date.now();\n\n    const {\n      width: streamWidth,\n      height: streamHeight,\n      deviceId,\n    } = this._userMediaStream?.getVideoTracks()[0].getSettings() || {};\n\n    const report: VideoInputTest.Report = {\n      deviceId,\n      errors: this._errors,\n      resolution: { width: streamWidth || 0, height: streamHeight || 0 },\n      testName: VideoInputTest.testName,\n    };\n\n    if (this._startTime) {\n      report.testTiming = {\n        duration: this._endTime - this._startTime,\n        end: this._endTime,\n        start: this._startTime,\n      };\n    }\n\n    this.emit(VideoInputTest.Events.End, report);\n\n    this._cleanup();\n  }\n\n  /**\n   * Clean up the test.\n   */\n  private _cleanup(): void {\n    if (this._userMediaStream) {\n      this._userMediaStream.getTracks().forEach((track: MediaStreamTrack) => {\n        track.stop();\n      });\n      this._userMediaStream = null;\n      if (this._options.element) {\n        const element: HTMLMediaElement = this._options.element;\n        const pausePromise: Promise<void> = this._playPromise\n          ? this._playPromise.then(() => {\n              element.pause();\n            })\n          : Promise.resolve();\n        pausePromise.finally(() => {\n          element.srcObject = null;\n          element.src = '';\n          element.load();\n        });\n      }\n    }\n    if (this._timeoutId) {\n      clearTimeout(this._timeoutId);\n      this._timeoutId = null;\n    }\n  }\n\n  /**\n   * Helper function that should be called when an error occurs, recoverable\n   * or not.\n   * @param error\n   */\n  private _onError(error: DiagnosticError): void {\n    this._errors.push(error);\n    this.emit(VideoInputTest.Events.Error, error);\n  }\n\n  /**\n   * Warning event handler.\n   * @param warning\n   */\n  private _onWarning(error: DiagnosticError): void {\n    if (this._options.debug) {\n      // tslint:disable-next-line no-console\n      console.warn(error);\n    }\n  }\n\n  /**\n   * Entry point of the test.\n   */\n  private async _startTest(): Promise<void> {\n    try {\n      const invalidReasons: InvalidityRecord<VideoInputTest.Options> | undefined =\n        await validateOptions<VideoInputTest.Options>(this._options, {\n          deviceId: validateDeviceId,\n          duration: validateTime,\n        });\n      if (invalidReasons) {\n        throw new InvalidOptionsError(invalidReasons);\n      }\n\n      if (!this._options.getUserMedia) {\n        throw GetUserMediaUnsupportedError;\n      }\n\n      this._userMediaStream = await this._options.getUserMedia({ video: {\n        deviceId: this._options.deviceId,\n        ...this._options.resolution,\n      } });\n\n      this._startTime = Date.now();\n\n      if (this._options.element) {\n        this._options.element.srcObject = this._userMediaStream;\n        this._playPromise = this._options.element.play();\n      }\n\n      if (this._options.duration && this._options.duration !== Infinity) {\n        this._timeoutId = setTimeout(() => this.stop(), this._options.duration);\n      }\n    } catch (error) {\n      if (error instanceof DiagnosticError) {\n        // There is some other fatal error.\n        this._onError(error);\n      } else if (\n        typeof DOMException !== 'undefined' && error instanceof DOMException\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMException` has occurred.',\n        ));\n      } else if (\n        typeof DOMError !== 'undefined' && error instanceof DOMError\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A `DOMError` has occurred.',\n        ));\n      } else {\n        this._onError(new DiagnosticError(\n          undefined,\n          'Unknown error occurred.',\n        ));\n        this._onWarning(error);\n      }\n      this.stop();\n    }\n  }\n}\n\nexport namespace VideoInputTest {\n  /**\n   * Possible events that a [[VideoInputTest]] might emit. See [[VideoInputTest.on]].\n   */\n  export enum Events {\n    End = 'end',\n    Error = 'error',\n  }\n\n  export interface Report {\n    /**\n     * The device ID used to get a MediaStream from using getUserMedia.\n     */\n    deviceId: string | undefined;\n    /**\n     * Any errors that occurred during the test.\n     */\n    errors: DiagnosticError[];\n    /**\n     * Resolution of the captured video frames in pixels.\n     */\n    resolution: VideoResolution;\n    /**\n     * The name of the test.\n     */\n    testName: string;\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming?: TimeMeasurement;\n  }\n\n  export interface Options {\n    /**\n     * Whether or not to log debug statements to the console.\n     * @private\n     */\n    debug?: boolean;\n    /**\n     * The device ID to try to get a MediaStream from using `getUserMedia`.\n     */\n    deviceId?: string;\n    /**\n     * Duration of time to run the test in milliseconds. If not specified, then\n     * the [[VideoInputTest]] will keep running until [[VideoInputTest.stop]] is\n     * called.\n     *\n     * @default Infinity\n     */\n    duration?: number;\n    /**\n     * The video element used to render the device feed. If not provided, then\n     * the video feed is not rendered.\n     */\n    element?: HTMLVideoElement;\n    /**\n     * Used to mock calls to `getUserMedia`.\n     * @private\n     */\n    getUserMedia?: typeof navigator.mediaDevices.getUserMedia;\n    /**\n     * The device's capture resolution in pixels. If not specified, then the\n     * default capture resolution is used.\n     */\n    resolution?: VideoResolution;\n  }\n\n  /**\n   * Option typing after initialization, so we can have type guarantees.\n   * @private\n   */\n  export type InternalOptions = SubsetRequired<Options, 'debug' | 'duration'>;\n}\n\n/**\n * This test examines video input capabilities. It serves to help diagnose\n * potential video device issues that would prevent video from being shared in\n * a WebRTC call.\n *\n * ---\n *\n * This test will use `getUserMedia` to try and capture a video stream from the\n * user. If this succeeds and an `HTMLMediaElement` is passed to the test within\n * the test options, then the stream will be bound to the element and should be\n * displayed.\n *\n * ---\n *\n * When the test ends, all of the tracks within the captured `MediaStream` are\n * ended and the `srcObject` of the `HTMLMediaElement` is set to `null`.\n */\nexport function testVideoInputDevice(\n  options?: VideoInputTest.Options,\n): VideoInputTest {\n  return new VideoInputTest(options);\n}\n"]}