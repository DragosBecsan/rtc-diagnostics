{"version":3,"file":"OutputTest.js","sourceRoot":"","sources":["../../lib/OutputTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport { INCOMING_SOUND_URL, TestNames } from './constants';\nimport {\n  AlreadyStoppedError,\n  DiagnosticError,\n  InvalidOptionsError,\n  UnsupportedError,\n} from './errors';\nimport {\n  Audio,\n  AudioContext,\n  AudioContextUnsupportedError,\n  AudioUnsupportedError,\n  enumerateDevices,\n  EnumerateDevicesUnsupportedError,\n  getDefaultDevices,\n} from './polyfills';\nimport {\n  AudioElement,\n  SubsetRequired,\n  TimeMeasurement,\n} from './types';\nimport {\n  InvalidityRecord,\n  validateDeviceId,\n  validateOptions,\n  validateTime,\n} from './utils/optionValidation';\n\nexport declare interface OutputTest {\n  /**\n   * This event is emitted when the test ends.\n   * @param event [[OutputTest.Events.End]]\n   * @param report A summary of the test.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.End,\n    report: OutputTest.Report,\n  ): boolean;\n  /**\n   * This event is emitted when the test encounters an error, fatal or not.\n   * @param event [[OutputTest.Events.Error]]\n   * @param error An error that was encountered during the run time of the test.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.Error,\n    error: DiagnosticError,\n  ): boolean;\n  /**\n   * This event is emitted by the test after succesfully starting, and emits\n   * the volume of the audio source every [[OutputTest.Options.volumeEventIntervalMs]]\n   * milliseconds.\n   * @param event [[OutputTest.Events.Volume]]\n   * @param value The volume of the audio source.\n   * @private\n   */\n  emit(\n    event: OutputTest.Events.Volume,\n    value: number,\n  ): boolean;\n\n  /**\n   * Raised when the test ends. The stop condition depends on if the option\n   * to loop was set to `true` or `false`. If `false`, then the test ends either\n   * when the audio file is finished playing, or when a time has elapsed\n   * greater than [[OutputTest.Options.duration]].\n   * @event\n   * @param event [[OutputTest.Events.End]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - A [[OutputTest.Report]] that summarizes the run time of the test.\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.End,\n    listener: (report: OutputTest.Report) => any,\n  ): this;\n  /**\n   * Raised when the test has run into an error, fatal or not.\n   * @event\n   * @param event [[OutputTest.Events.Error]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - The [[DiagnosticError]].\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n  /**\n   * Raised every [[OutputTest.Options.volumeEventIntervalMs]] after the test\n   * starts successfully. Will have a `number` parameter representing the\n   * current volume of the audio file.\n   * @event\n   * @param event [[OutputTest.Events.Volume]]\n   * @param listener A listener function that expects the following parameters\n   * when the event is raised:\n   * - A number representing the volume of the audio source.\n   * @returns This [[OutputTest]] instance.\n   */\n  on(\n    event: OutputTest.Events.Volume,\n    listener: (value: number) => any,\n  ): this;\n}\n\n/**\n * [[OutputTest]] class that parses options and starts an audio output device\n * test.\n *\n * Please see [[testOutputDevice]] for details and recommended practices.\n */\nexport class OutputTest extends EventEmitter {\n  /**\n   * The name of the test.\n   */\n  static testName: TestNames.OutputAudioDevice = TestNames.OutputAudioDevice;\n  /**\n   * Default options for the [[OutputTest]]. Overwritten by any option passed\n   * during the construction of the test.\n   */\n  private static defaultOptions: OutputTest.InternalOptions = {\n    audioContextFactory: AudioContext,\n    audioElementFactory: Audio,\n    debug: false,\n    doLoop: true,\n    duration: Infinity,\n    enumerateDevices,\n    passOnTimeout: true,\n    testURI: INCOMING_SOUND_URL,\n    volumeEventIntervalMs: 100,\n  };\n\n  /**\n   * Holds `AudioElement`s that are attached to the DOM to load and play audio.\n   */\n  private _audio: AudioElement[] = [];\n  /**\n   * An `AudioContext` that is used to process the audio source.\n   */\n  private _audioContext: AudioContext | null = null;\n  /**\n   * The default media devices when starting the test.\n   */\n  private _defaultDevices: Partial<Record<\n    MediaDeviceKind,\n    MediaDeviceInfo\n  >> = {};\n  /**\n   * A timestamp of when the test ends.\n   */\n  private _endTime: number | null = null;\n  /**\n   * An array of errors encountered by the test during its run time.\n   */\n  private readonly _errors: DiagnosticError[] = [];\n  /**\n   * Options passed to and set in the constructor to be used during the run\n   * time of the test.\n   */\n  private _options: OutputTest.InternalOptions;\n  /**\n   * A timestamp of when the test starts. This is set in the constructor and not\n   * when the test succesfully starts.\n   */\n  private _startTime: number;\n  /**\n   * Volume values generated by the test over its run time.\n   */\n  private readonly _values: number[] = [];\n  /**\n   * Timeout created by `setTimeout`, used to loop the volume logic.\n   */\n  private _volumeTimeout: NodeJS.Timeout | null = null;\n\n  /**\n   * Sets up several things for the `OutputTest` to run later in the\n   * `_startTest` function.\n   * @param options Optional settings to pass to the test.\n   */\n  constructor(options?: OutputTest.Options) {\n    super();\n\n    this._options = { ...OutputTest.defaultOptions, ...options };\n\n    this._startTime = Date.now();\n\n    // We need to use a `setTimeout` here to prevent a race condition.\n    // This allows event listeners to bind before the test starts.\n    setTimeout(() => this._startTest());\n  }\n\n  /**\n   * Stops the test.\n   * @param pass whether or not the test should pass. If set to false, will\n   * override the result from determining whether audio is silent from the collected volume values.\n   */\n  stop(pass: boolean = true): OutputTest.Report | undefined {\n    if (this._endTime) {\n      this._onWarning(new AlreadyStoppedError());\n      return;\n    }\n\n    // Clean up the test.\n    this._cleanup();\n\n    this._endTime = Date.now();\n    const report: OutputTest.Report = {\n      deviceId: this._options.deviceId || (\n        this._defaultDevices.audiooutput &&\n        this._defaultDevices.audiooutput.deviceId\n      ),\n      didPass: pass,\n      errors: this._errors,\n      testName: OutputTest.testName,\n      testTiming: {\n        duration: this._endTime - this._startTime,\n        end: this._endTime,\n        start: this._startTime,\n      },\n      testURI: this._options.testURI,\n      values: this._values,\n    };\n    this.emit(OutputTest.Events.End, report);\n\n    return report;\n  }\n\n  /**\n   * Cleanup the test.\n   */\n  private _cleanup(): void {\n    if (this._volumeTimeout) {\n      clearTimeout(this._volumeTimeout);\n    }\n    if (this._audioContext) {\n      this._audioContext.close();\n    }\n    this._audio.forEach((audio: AudioElement) => {\n      audio.pause();\n    });\n  }\n\n  /**\n   * Error event handler. Adds the error to the internal list of errors that is\n   * forwarded in the report.\n   * @param error\n   */\n  private _onError(error: DiagnosticError): void {\n    this._errors.push(error);\n    this.emit(OutputTest.Events.Error, error);\n  }\n\n  /**\n   * Volume event handler, adds the value to the list `_values` and emits it\n   * under the event `volume`.\n   * @param volume\n   */\n  private _onVolume(volume: number): void {\n    this._values.push(volume);\n    this.emit(OutputTest.Events.Volume, volume);\n  }\n\n  /**\n   * Warning event handler.\n   * @param warning\n   */\n  private _onWarning(error: DiagnosticError): void {\n    if (this._options.debug) {\n      // tslint:disable-next-line no-console\n      console.warn(error);\n    }\n  }\n\n  /**\n   * Entry point of the test, called after setup in the constructor.\n   * Emits the volume levels of the audio.\n   *\n   * @event [[OutputTest.Events.Volume]]\n   */\n  private async _startTest(): Promise<void> {\n    try {\n      // Try to validate all of the inputs before starting the test.\n      // We perform this check here so if the validation throws, it gets handled\n      // properly as a fatal-error and we still emit a report with that error.\n      const invalidReasons: InvalidityRecord<OutputTest.Options> | undefined =\n        await validateOptions<OutputTest.Options>(this._options, {\n          deviceId: validateDeviceId,\n          duration: validateTime,\n          volumeEventIntervalMs: validateTime,\n        });\n      if (invalidReasons) {\n        throw new InvalidOptionsError(invalidReasons);\n      }\n\n      if (!this._options.audioElementFactory) {\n        throw AudioUnsupportedError;\n      }\n      if (!this._options.audioContextFactory) {\n        throw AudioContextUnsupportedError;\n      }\n\n      const setSinkIdSupported: boolean =\n        typeof this._options.audioElementFactory.prototype.setSinkId === 'function';\n      if (setSinkIdSupported) {\n        if (!this._options.enumerateDevices) {\n          throw EnumerateDevicesUnsupportedError;\n        }\n\n        const devices: MediaDeviceInfo[] = await this._options.enumerateDevices();\n\n        const numberOutputDevices: number = devices.filter(\n          (device: MediaDeviceInfo) => device.kind === 'audiooutput',\n        ).length;\n        if (numberOutputDevices === 0) {\n          throw new DiagnosticError(undefined, 'No output devices found.');\n        }\n\n        this._defaultDevices = getDefaultDevices(devices);\n      }\n\n      this._audioContext = new this._options.audioContextFactory();\n\n      const sourceAudio: AudioElement =\n        new this._options.audioElementFactory(this._options.testURI);\n      sourceAudio.setAttribute('crossorigin', 'anonymous');\n      sourceAudio.loop = !!this._options.doLoop;\n\n      const sourceNode: MediaElementAudioSourceNode =\n        this._audioContext.createMediaElementSource(sourceAudio);\n\n      const analyser: AnalyserNode = this._audioContext.createAnalyser();\n      analyser.smoothingTimeConstant = 0.4;\n      analyser.fftSize = 64;\n      sourceNode.connect(analyser);\n\n      const frequencyDataBytes: Uint8Array =\n        new Uint8Array(analyser.frequencyBinCount);\n      const volumeEvent: () => void = (): void => {\n        if (this._endTime) {\n          return;\n        }\n\n        analyser.getByteFrequencyData(frequencyDataBytes);\n        const volume: number =\n          frequencyDataBytes.reduce(\n            (sum: number, val: number) => sum + val,\n            0,\n          ) / frequencyDataBytes.length;\n        this._onVolume(volume);\n\n        // Check stop conditions\n        const isTimedOut: boolean =\n          Date.now() - this._startTime > this._options.duration;\n        const stop: boolean = this._options.doLoop\n          ? isTimedOut\n          : sourceAudio.ended || isTimedOut;\n\n        if (stop) {\n          if (this._options.passOnTimeout === false) {\n            this._onError(new DiagnosticError(\n              undefined,\n              'Test timed out.',\n            ));\n          }\n          this.stop(this._options.passOnTimeout);\n        } else {\n          this._volumeTimeout = setTimeout(\n            volumeEvent,\n            this._options.volumeEventIntervalMs,\n          );\n        }\n      };\n\n      if (this._options.deviceId && setSinkIdSupported) {\n        const destinationNode: MediaStreamAudioDestinationNode =\n          this._audioContext.createMediaStreamDestination();\n        analyser.connect(destinationNode);\n\n        const destinationAudio: AudioElement =\n          new this._options.audioElementFactory();\n        destinationAudio.loop = !!this._options.doLoop;\n        destinationAudio.srcObject = destinationNode.stream;\n\n        await destinationAudio.setSinkId?.(this._options.deviceId);\n        await destinationAudio.play();\n        this._audio.push(destinationAudio);\n      } else {\n        if (this._options.deviceId && !setSinkIdSupported) {\n          // Non-fatal error\n          this._onError(new UnsupportedError(\n            'A `deviceId` was passed to the `OutputTest` but `setSinkId` is ' +\n            'not supported in this browser.',\n          ));\n        }\n        analyser.connect(this._audioContext.destination);\n      }\n\n      await sourceAudio.play();\n      this._audio.push(sourceAudio);\n\n      this._volumeTimeout = setTimeout(\n        volumeEvent,\n        this._options.volumeEventIntervalMs,\n      );\n    } catch (error) {\n      if (error instanceof DiagnosticError) {\n        this._onError(error);\n      } else if (\n        typeof DOMException !== 'undefined' && error instanceof DOMException\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A DOMException has occurred.',\n        ));\n      } else if (\n        typeof DOMError !== 'undefined' && error instanceof DOMError\n      ) {\n        this._onError(new DiagnosticError(\n          error,\n          'A DOMError has occurred.',\n        ));\n      } else {\n        this._onError(new DiagnosticError(\n          undefined,\n          'Unknown error occurred.',\n        ));\n        this._onWarning(error);\n      }\n      this.stop(false);\n    }\n  }\n}\n\nexport namespace OutputTest {\n  /**\n   * Events that the OutputTest will emit as it runs.\n   * Please see [[OutputTest.on]] for how to listen to these\n   * events.\n   */\n  export enum Events {\n    End = 'end',\n    Error = 'error',\n    Volume = 'volume',\n  }\n\n  /**\n   * Options passed to [[OutputTest]] constructor.\n   */\n  export interface Options {\n    /**\n     * An `AudioContext` to be used by the test.\n     * @private\n     */\n    audioContextFactory?: typeof window.AudioContext;\n\n    /**\n     * A constuctor that is used to create an [[AudioElement]], useful for\n     * mocks.\n     * @private\n     */\n    audioElementFactory?: new (...args: any[]) => AudioElement;\n\n    /**\n     * Whether or not to log debug statements to the console.\n     * @private\n     */\n    debug?: boolean;\n\n    /**\n     * The `deviceId` of the audio device to attempt to play audio out of.\n     * This option is directly passed to [HTMLMediaElement.setSinkId](https://developer.mozilla.org/en-US/docs/Web/API/HTMLMediaElement/setSinkId).\n     */\n    deviceId?: string;\n\n    /**\n     * Whether or not to loop the audio.\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default true\n     */\n    doLoop?: boolean;\n\n    /**\n     * Duration in milliseconds to run the test for. If this amount of time elapses, the test\n     * is considered \"timed out\".\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default Infinity\n     */\n    duration?: number;\n\n    /**\n     * Used to mock the call to `enumerateDevices`.\n     * @private\n     */\n    enumerateDevices?: typeof navigator.mediaDevices.enumerateDevices;\n\n    /**\n     * Set [[OutputTest.Report.didPass]] to true or not upon test timeout.\n     * See [[OutputTest]] for details on the behavior of \"timing out\".\n     * @default true\n     */\n    passOnTimeout?: boolean;\n\n    /**\n     * The URI of the audio file to use for the test.\n     */\n    testURI?: string;\n\n    /**\n     * The interval between emissions of volume events in milliseconds.\n     * @default 100\n     */\n    volumeEventIntervalMs?: number;\n  }\n\n  /**\n   * Represents the report generated from an [[OutputTest]].\n   */\n  export interface Report {\n    /**\n     * The `deviceId` of the audio device used to play audio out of.\n     */\n    deviceId: string | undefined;\n\n    /**\n     * Whether or not the test passed. See [[OutputTest]] for determining pass or fail.\n     */\n    didPass: boolean;\n\n    /**\n     * Any errors that occurred during the run-time of the [[OutputTest]].\n     */\n    errors: DiagnosticError[];\n\n    /**\n     * Name of the test, set to [[OutputTest.testName]].\n     */\n    testName: typeof OutputTest.testName;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming: TimeMeasurement;\n\n    /**\n     * The URI of the audio file used during the test.\n     */\n    testURI?: string;\n\n    /**\n     * The volume values emitted by the test during its run-time.\n     */\n    values: number[];\n  }\n\n  /**\n   * Option typing after initialization, so we can have type guarantees.\n   * @private\n   */\n  export type InternalOptions = SubsetRequired<Options,\n    'doLoop' | 'duration' | 'passOnTimeout' | 'volumeEventIntervalMs' | 'testURI'>;\n}\n\n/**\n * [[OutputTest]] tests audio output capabilities. It serves to help diagnose\n * potential audio device issues that would prevent a user from being able to\n * hear audio.\n *\n * ---\n *\n * The [[OutputTest]] class is an `EventEmitter` (please see [[OutputTest.on]] for\n * events and their details) and helps to diagnose issues by playing a sound clip\n * (by default the sound clip is the ringing tone from the `twilio-client.js`\n * SDK) and emitting volume events of the sound clip as it plays.\n * ```ts\n * import { OutputTest, testOutputDevice } from '@twilio/rtc-diagnostics';\n * const options: OutputTest.Options = { ... };\n * // `options` may be left `undefined` to use default option values\n * const outputTest: OutputTest = testOutputDevice(options);\n * ```\n * The application can use the volume events to show in its UI that audio is\n * playing and that the end-user should be hearing something.\n * ```ts\n * outputTest.on(OutputTest.Events.Volume, (volume: number) => {\n *   ui.updateVolume(volume); // Update your UI with the volume value here.\n * });\n * ```\n *\n * The application should ask the end-user to confirm that the sound being played\n * can be heard. The application should call [[OutputTest.stop]] with `true` if\n * the end-user hears the sound, and `false` if not.\n * ```ts\n * // If the user was able to hear the audio, the UI should indicate they should\n * // click this button...\n * const passButton = ...;\n * passButton.on('click', () => {\n *   outputTest.stop(false);\n * });\n *\n * // ...conversely, if they were not able to hear the audio, they should click\n * // this one.\n * const failButton = ...;\n * failButton.on('click', () => {\n *   outputTest.stop(end);\n * });\n * ```\n * Caling [[OutputTest.stop]] will immediately end the test. The value of\n * [[OutputTest.Report.didPass]] will be the value passed to\n * [[OutputTest.stop]].\n *\n * ---\n *\n * The [[OutputTest]] object will always emit a [[OutputTest.Report]] with\n * the [[OutputTest.Events.End]] event, regardless of the occurence of errors\n * during the runtime of the test.\n *\n * Fatal errors will immediately end the test and emit a report such that\n * the value of [[OutputTest.Report.didPass]] will be `false` and the value of\n * [[OutputTest.Report.errors]] will contain the fatal error.\n *\n * Non-fatal errors will not end the test, but will be included in the value of\n * [[OutputTest.Report.errors]] upon completion of the test.\n *\n * If the data at `testURI` is unable to be loaded, meaning the error event is\n * raised on the audio element, a fatal error has occurred.\n *\n * If `doLoop` is set to `false`, then the test will run for either the option\n * `duration`, or the full duration of the audio file, which ever is shorter.\n * If `doLoop` is set to `true`, it will only run as long as the `duration`\n * option.\n * If the test times out (as defined by the `duration` in the `options`\n * parameter), then the test is considered passing or not by the `passOnTimeout`\n * option and ends.\n *\n * ---\n *\n * The function [[testOutputDevice]] serves as factory function that accepts\n * [[OutputTest.Options]] as its only parameter and will instantiate an\n * [[OutputTest]] object with those options.\n * ```ts\n * import { OutputTest, testOutputDevice } from '@twilio/rtc-diagnostics';\n * const options: OutputTest.Options = { ... };\n * const outputTest: OutputTest = testOutputDevice(options);\n * ```\n * @param options Options to pass to the [[OutputTest]] constructor.\n */\nexport function testOutputDevice(\n  options?: OutputTest.Options,\n): OutputTest {\n  return new OutputTest(options);\n}\n"]}