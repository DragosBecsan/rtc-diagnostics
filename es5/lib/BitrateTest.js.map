{"version":3,"file":"BitrateTest.js","sourceRoot":"","sources":["../../lib/BitrateTest.ts"],"names":[],"mappings":"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","sourcesContent":["import { EventEmitter } from 'events';\nimport {\n  BITRATE_TEST_TIMEOUT_MS,\n  BYTES_KEEP_BUFFERED,\n  MAX_NUMBER_PACKETS,\n  MIN_BITRATE_THRESHOLD,\n  TEST_PACKET,\n} from './constants';\nimport { DiagnosticError } from './errors/DiagnosticError';\nimport { TimeMeasurement } from './types';\nimport {\n  getRTCIceCandidateStatsReport,\n  RTCIceCandidateStats,\n  RTCIceCandidateStatsReport,\n  RTCSelectedIceCandidatePairStats,\n} from './utils/candidate';\n\nexport declare interface BitrateTest {\n  /**\n   * Raised every second with a `bitrate` parameter in kbps which represents the connection's bitrate since the last time this event was raised.\n   * The bitrate value is limited by either your downlink or uplink, whichever is lower.\n   * For example, if your downlink and uplink is 50mbps and 10mbps respectively, bitrate value will not exceed 10mbps.\n   * @param event [[BitrateTest.Events.Bitrate]].\n   * @param listener A callback with a `bitrate`(kbps) parameter since the last time this event was raised.\n   * @returns This [[BitrateTest]] instance.\n   * @event\n   */\n  on(\n    event: BitrateTest.Events.Bitrate,\n    listener: (bitrate: number) => any,\n  ): this;\n\n  /**\n   * Raised when the test encounters an error.\n   * When this happens, the test will immediately stop and emit [[BitrateTest.Events.End]].\n   * @param event [[BitrateTest.Events.Error]].\n   * @param listener A callback with a [[DiagnosticError]] parameter.\n   * @returns This [[BitrateTest]] instance.\n   * @event\n   */\n  on(\n    event: BitrateTest.Events.Error,\n    listener: (error: DiagnosticError) => any,\n  ): this;\n\n  /**\n   * Raised upon completion of the test.\n   * @param event [[BitrateTest.Events.End]].\n   * @param listener A callback with a [[BitrateTest.Report]] parameter.\n   * @returns This [[BitrateTest]] instance.\n   * @event\n   */\n  on(\n    event: BitrateTest.Events.End,\n    listener: (report: BitrateTest.Report) => any,\n  ): this;\n}\n\n/**\n * BitrateTest uses two [RTCPeerConnections](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n * connected via a [Twilio Network Traversal Service](https://www.twilio.com/docs/stun-turn).\n * Using [RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel), one RTCPeerConnection will saturate the data channel buffer and will\n * constantly send data packets to the other RTCPeerConnection. The receiving peer will measure the bitrate base on the amount of packets received every second.\n * See [[BitrateTest.Options.iceServers]] for information how to use Twilio NTS.\n */\nexport class BitrateTest extends EventEmitter {\n  /**\n   * Name of this test\n   */\n  static readonly testName: string = 'bitrate-test';\n\n  /**\n   * Interval id for checking bitrate\n   */\n  private _checkBitrateIntervalId: NodeJS.Timer | undefined;\n\n  /**\n   * A timestamp of when the test ends.\n   */\n  private _endTime: number | null = null;\n\n  /**\n   * Errors detected during the test\n   */\n  private _errors: DiagnosticError[] = [];\n\n  /**\n   * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n   */\n  private _iceCandidateStats: RTCIceCandidateStats[] = [];\n\n  /**\n   * Number of bytes received the last time it was checked\n   */\n  private _lastBytesChecked: number = 0;\n\n  /**\n   * Last timestamp when the bytes received was checked\n   */\n  private _lastCheckedTimestamp: number = 0;\n\n  /**\n   * The options passed to [[BitrateTest]] constructor.\n   */\n  private _options: BitrateTest.ExtendedOptions;\n\n  /**\n   * The RTCPeerConnection that will receive data\n   */\n  private _pcReceiver: RTCPeerConnection;\n\n  /**\n   * The RTCPeerConnection that will send data\n   */\n  private _pcSender: RTCPeerConnection;\n\n  /**\n   * RTC configuration that will be used when initializing a RTCPeerConnection\n   */\n  private _rtcConfiguration: RTCConfiguration = {};\n\n  /**\n   * RTCDataChannel to use for sending data\n   */\n  private _rtcDataChannel: RTCDataChannel | undefined;\n\n  /**\n   * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n   */\n  private _selectedIceCandidatePairStats: RTCSelectedIceCandidatePairStats | undefined;\n\n  /**\n   * Interval id for sending data\n   */\n  private _sendDataIntervalId: NodeJS.Timer | undefined;\n\n  /**\n   * A timestamp of when the test starts. This is set during initialization of the test\n   * and not when the test succesfully starts.\n   */\n  private _startTime: number;\n\n  /**\n   * Timeout reference that should be cleared when we receive any data. If this\n   * times out, it means something has timed out our BitrateTest.\n   */\n  private _timeout: NodeJS.Timer;\n\n  /**\n   * Total number of bytes received by the receiver RTCPeerConnection\n   */\n  private _totalBytesReceived: number = 0;\n\n  /**\n   * Bitrate (kbps) values collected during the test\n   */\n  private _values: number[] = [];\n\n  /**\n   * Construct a [[BitrateTest]] instance. The test will start immediately.\n   * Test should be allowed to run for a minimum of 8 seconds. To stop the test, call [[BitrateTest.stop]].\n   * @constructor\n   * @param options\n   */\n  constructor(options: BitrateTest.ExtendedOptions) {\n    super();\n\n    this._options = { ...options };\n    this._rtcConfiguration.iceServers = this._options.iceServers;\n\n    this._pcReceiver = new RTCPeerConnection(this._rtcConfiguration);\n    this._pcSender = new RTCPeerConnection(this._rtcConfiguration);\n\n    this._pcReceiver.onicecandidate = (event: RTCPeerConnectionIceEvent) => this._onIceCandidate(this._pcSender, event);\n    this._pcSender.onicecandidate = (event: RTCPeerConnectionIceEvent) => this._onIceCandidate(this._pcReceiver, event);\n\n    this._setupNetworkListeners(this._pcSender);\n\n    this._startTime = Date.now();\n\n    // Return before starting the test to allow consumer\n    // to listen and capture errors\n    setTimeout(() => {\n      this._setupDataChannel();\n      this._startTest();\n    });\n\n    this._timeout = setTimeout(() => {\n      this._onError(`Network timeout; exceeded limit of ${BITRATE_TEST_TIMEOUT_MS}ms`);\n    }, BITRATE_TEST_TIMEOUT_MS);\n  }\n\n  /**\n   * Stops the current test.\n   */\n  stop(): void {\n    clearTimeout(this._timeout!);\n    clearInterval(this._sendDataIntervalId!);\n    clearInterval(this._checkBitrateIntervalId!);\n\n    if (typeof this._endTime !== 'number' || this._endTime === 0) {\n      this._pcSender.close();\n      this._pcReceiver.close();\n      this._endTime = Date.now();\n\n      this.emit(BitrateTest.Events.End, this._getReport());\n    }\n  }\n\n  /**\n   * Calculate bitrate by comparing bytes received between current time and the last time it was checked\n   */\n  private _checkBitrate(): void {\n    // No data yet\n    if (!this._lastCheckedTimestamp || !this._lastBytesChecked) {\n      this._lastCheckedTimestamp = Date.now();\n      this._lastBytesChecked = this._totalBytesReceived;\n      return;\n    }\n\n    // Calculate bitrate in kbps\n    const now = Date.now();\n    const bitrate = 8 * (this._totalBytesReceived - this._lastBytesChecked) / (now - this._lastCheckedTimestamp);\n\n    if (bitrate > 0) {\n      clearTimeout(this._timeout!);\n    }\n\n    this._lastCheckedTimestamp = now;\n    this._lastBytesChecked = this._totalBytesReceived;\n    this._values.push(bitrate);\n    this.emit(BitrateTest.Events.Bitrate, bitrate);\n  }\n\n  /**\n   * Generate and returns the report for this test\n   */\n  private _getReport(): BitrateTest.Report {\n    let averageBitrate = this._values\n      .reduce((total: number, value: number) => total += value, 0) / this._values.length;\n    averageBitrate = isNaN(averageBitrate) ? 0 : averageBitrate;\n\n    const testTiming: TimeMeasurement = { start: this._startTime };\n    if (this._endTime) {\n      testTiming.end = this._endTime;\n      testTiming.duration = this._endTime - this._startTime;\n    }\n\n    const report: BitrateTest.Report = {\n      averageBitrate,\n      didPass: !this._errors.length && !!this._values.length && averageBitrate >= MIN_BITRATE_THRESHOLD,\n      errors: this._errors,\n      iceCandidateStats: this._iceCandidateStats,\n      testName: BitrateTest.testName,\n      testTiming,\n      values: this._values,\n    };\n\n    if (this._selectedIceCandidatePairStats) {\n      report.selectedIceCandidatePairStats = this._selectedIceCandidatePairStats;\n    }\n\n    return report;\n  }\n\n  /**\n   * Called when an error is detected\n   * @param message - Message that describes the error\n   * @param error - The error object\n   * @param isFatal - Whether this is a fatal error\n   */\n  private _onError(message: string, error?: DOMError): void {\n    const diagnosticError = new DiagnosticError(error, message);\n    this._errors.push(diagnosticError);\n    this.emit(BitrateTest.Events.Error, diagnosticError);\n    this.stop();\n  }\n\n  /**\n   * Called when a local candidate is gathered\n   * @param remotePc - The remote RTCPeerConnection\n   */\n  private _onIceCandidate(remotePc: RTCPeerConnection, event: RTCPeerConnectionIceEvent): void {\n    if (event.candidate) {\n      const candidate = event.candidate.candidate;\n      if (candidate.indexOf('relay') !== -1) {\n        remotePc.addIceCandidate(event.candidate)\n          .catch((error: DOMError) => this._onError('Unable to add candidate', error));\n      }\n    }\n  }\n\n  /**\n   * Called when a message is received\n   * @param event\n   */\n  private _onMessageReceived(event: MessageEvent) {\n    this._totalBytesReceived += event.data.length;\n  }\n\n  /**\n   * Called when an answer is created by the receiver\n   * @param answer - The answer session description created by the receiver RTCPeerConnection\n   */\n  private _onReceiverAnswerCreated(answer: RTCSessionDescriptionInit): Promise<void | [void, void]> {\n    return Promise.all([\n      this._pcReceiver.setLocalDescription(answer),\n      this._pcSender.setRemoteDescription(answer),\n    ]).catch((error: DOMError) =>\n      this._onError('Unable to set local or remote description from createAnswer', error));\n  }\n\n  /**\n   * Called when an offer has been created by the sender\n   * @param offer - The offer session description created by the sender RTCPeerConnection\n   */\n  private _onSenderOfferCreated(offer: RTCSessionDescriptionInit): Promise<void | [void, void]> {\n    return Promise.all([\n      this._pcSender.setLocalDescription(offer),\n      this._pcReceiver.setRemoteDescription(offer),\n    ]).catch((error: DOMError) =>\n      this._onError('Unable to set local or remote description from createOffer', error));\n  }\n\n  /**\n   * Send packets using data channel\n   */\n  private _sendData(): void {\n    if (!this._rtcDataChannel || this._rtcDataChannel.readyState !== 'open') {\n      return;\n    }\n    for (let i = 0; i < MAX_NUMBER_PACKETS; ++i) {\n      if (this._rtcDataChannel.bufferedAmount >= BYTES_KEEP_BUFFERED) {\n        break;\n      }\n      this._rtcDataChannel.send(TEST_PACKET);\n    }\n  }\n\n  /**\n   * Setup data channel for sending data\n   */\n  private _setupDataChannel(): void {\n    try {\n      this._rtcDataChannel = this._pcSender.createDataChannel('sender');\n    } catch (e) {\n      this._onError('Error creating data channel', e);\n      return;\n    }\n\n    this._rtcDataChannel.onopen = () => {\n      this._sendDataIntervalId = setInterval(() => this._sendData(), 1);\n      this._checkBitrateIntervalId = setInterval(() => this._checkBitrate(), 1000);\n    };\n\n    this._pcReceiver.ondatachannel = (dataChannelEvent: RTCDataChannelEvent) => {\n      dataChannelEvent.channel.onmessage = (event: MessageEvent) => this._onMessageReceived(event);\n    };\n  }\n\n  /**\n   * Setup network related event listeners on a PeerConnection\n   * @param pc\n   */\n  private _setupNetworkListeners(pc: RTCPeerConnection) {\n    pc.oniceconnectionstatechange = () => {\n      if (pc.iceConnectionState === 'connected') {\n        (this._options.getRTCIceCandidateStatsReport || getRTCIceCandidateStatsReport)(this._pcSender)\n          .then((statsReport: RTCIceCandidateStatsReport) => {\n            this._iceCandidateStats = statsReport.iceCandidateStats;\n            this._selectedIceCandidatePairStats = statsReport.selectedIceCandidatePairStats;\n          })\n          .catch((error: DOMError) => {\n            this._onError('Unable to generate WebRTC stats report', error);\n          });\n      }\n    };\n  }\n\n  /**\n   * Starts the test.\n   */\n  private _startTest(): void {\n    if (!this._rtcConfiguration.iceServers) {\n      return this._onError('No iceServers found', undefined);\n    }\n\n    this._pcSender.createOffer()\n      .then((offer: RTCSessionDescriptionInit) => this._onSenderOfferCreated(offer))\n      .then(() => {\n        return this._pcReceiver.createAnswer()\n          .then((answer: RTCSessionDescriptionInit) => this._onReceiverAnswerCreated(answer))\n          .catch((error: Error) => this._onError('Unable to create answer', error));\n      }).catch((error: Error) => this._onError('Unable to create offer', error));\n  }\n}\n\nexport namespace BitrateTest {\n  /**\n   * Possible events that a [[BitrateTest]] might emit. See [[BitrateTest.on]].\n   */\n  export enum Events {\n    Bitrate = 'bitrate',\n    End = 'end',\n    Error = 'error',\n  }\n\n  /**\n   * Options that may be passed to [[BitrateTest]] constructor for internal testing.\n   * @internalapi\n   */\n  export interface ExtendedOptions extends Options {\n    /**\n     * A function that generates a WebRTC stats report containing relevant information about ICE candidates for\n     * the given [PeerConnection](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection)\n     */\n    getRTCIceCandidateStatsReport?: (peerConnection: RTCPeerConnection) => Promise<RTCIceCandidateStatsReport>;\n  }\n\n  /**\n   * Options passed to [[BitrateTest]] constructor.\n   */\n  export interface Options {\n    /**\n     * The array of [RTCIceServer](https://developer.mozilla.org/en-US/docs/Web/API/RTCIceServer) configurations to use.\n     * You need to provide TURN server configurations to ensure that your network bitrate is tested.\n     * You you can use [Twilio's Network Traversal Service](https://www.twilio.com/stun-turn) to get TURN credentials.\n     *\n     * The following example demonstrates how to use the [twilio npm module](https://www.npmjs.com/package/twilio) to generate\n     * credentials with a ttl of 120 seconds, using UDP protocol, and specifying ashburn as the\n     * [edge location](https://www.twilio.com/docs/global-infrastructure/edge-locations).\n     *\n     * ```ts\n     * import Client from 'twilio';\n     * import { testBitrate } from '@twilio/rtc-diagnostics';\n     *\n     * // Generate the STUN and TURN server credentials with a ttl of 120 seconds\n     * const client = Client(twilioAccountSid, authToken);\n     * const token = await client.tokens.create({ ttl: 120 });\n     *\n     * // Filter for TURN servers.\n     * // Use the following filters if you want to use UDP, TCP, or TLS\n     * // UDP: turn:global.turn.twilio.com:3478?transport=udp\n     * // TCP: turn:global.turn.twilio.com:3478?transport=tcp\n     * // TLS: turn:global.turn.twilio.com:443?transport=tcp\n     * let { urls, username, credential } = token.iceServers\n     *   .find(item => item.url === 'turn:global.turn.twilio.com:3478?transport=udp');\n     *\n     * // By default, global will be used as the default edge location.\n     * // You can replace global with a specific edge name.\n     * urls = urls.replace('global', 'ashburn');\n     *\n     * // Use the TURN credentials using the iceServers parameter\n     * const bitrateTest = testBitrate({ iceServers: [{ urls, username, credential }] });\n     * ```\n     * Note, for production code, the above code should not be executed client side as it requires the authToken which must be treated like a private key.\n     */\n    iceServers: RTCIceServer[];\n  }\n\n  /**\n   * Represents the report generated from a [[BitrateTest]].\n   */\n  export interface Report {\n    /**\n     * Average bitrate calculated during the test.\n     */\n    averageBitrate: number;\n\n    /**\n     * Whether or not the test passed.\n     * The test is considered to be passing if there were no errors detected and average bitrate is greater than the minimum bitrate required to make a call.\n     * See [Network Bandwidth Requirements](https://www.twilio.com/docs/voice/client/javascript/voice-client-js-and-mobile-sdks-network-connectivity-requirements#network-bandwidth-requirements)\n     */\n    didPass: boolean;\n\n    /**\n     * Any errors that occurred during the test.\n     */\n    errors: DiagnosticError[];\n\n    /**\n     * An array of WebRTC stats for the ICE candidates gathered when connecting to media.\n     */\n    iceCandidateStats: RTCIceCandidateStats[];\n\n    /**\n     * A WebRTC stats for the ICE candidate pair used to connect to media, if candidates were selected.\n     */\n    selectedIceCandidatePairStats?: RTCSelectedIceCandidatePairStats;\n\n    /**\n     * The name of the test.\n     */\n    testName: string;\n\n    /**\n     * Time measurements of test run time.\n     */\n    testTiming: TimeMeasurement;\n\n    /**\n     * Bitrate values collected during the test.\n     */\n    values: number[];\n  }\n}\n\n/**\n * The test uses two [RTCPeerConnections](https://developer.mozilla.org/en-US/docs/Web/API/RTCPeerConnection) connected via a Twilio TURN server.\n * Using [RTCDataChannel](https://developer.mozilla.org/en-US/docs/Web/API/RTCDataChannel), one RTCPeerConnection will saturate the data channel buffer and will\n * constantly send data packets to the other RTCPeerConnection. The receiving peer will measure the bitrate base on the amount of packets received every second.\n *\n * Example:\n * ```ts\n *   import { testBitrate } from '@twilio/rtc-diagnostics';\n *\n *   const bitrateTest = testBitrate({\n *     iceServers: [{\n *       credential: 'bar',\n *       username: 'foo',\n *       urls: 'turn:global.turn.twilio.com:3478?transport=udp',\n *     }],\n *   });\n *\n *   bitrateTest.on('bitrate', (bitrate) => {\n *     console.log(bitrate);\n *   });\n *\n *   bitrateTest.on('error', (error) => {\n *     console.log(error);\n *   });\n *\n *   bitrateTest.on('end', (report) => {\n *     console.log(report);\n *   });\n *\n *   // Run the test for 15 seconds\n *   setTimeout(() => {\n *     bitrateTest.stop();\n *   }, 15000);\n * ```\n * See [[BitrateTest.Options.iceServers]] for details on how to obtain TURN credentials.\n */\nexport function testBitrate(options: BitrateTest.Options): BitrateTest {\n  return new BitrateTest(options);\n}\n"]}